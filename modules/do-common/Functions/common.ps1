$ErrorActionPreference = 'Stop'

<#
.SYNOPSIS
Retry executing command if fails on HttpRequestException.
.PARAMETER Script
Script block of commands to execute.
#>
function Invoke-CommandRetry {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory)]
        [scriptblock]$Script
    )
    do {
        try {
            Invoke-Command -ScriptBlock $Script
            $exit = $true
        } catch [System.Net.Http.HttpRequestException] {
            if ($_.Exception.TargetSite.Name -eq 'MoveNext') {
                if ($_.ErrorDetails) {
                    Write-Verbose $_.ErrorDetails.Message
                } else {
                    Write-Verbose $_.Exception.Message
                }
                Write-Host 'Retrying...'
            } else {
                Write-Verbose $_.Exception.GetType().FullName
                Write-Error $_
            }
        } catch [System.AggregateException] {
            if ($_.Exception.InnerException.GetType().Name -eq 'HttpRequestException') {
                Write-Verbose $_.Exception.InnerException.Message
                Write-Host 'Retrying...'
            } else {
                Write-Verbose $_.Exception.InnerException.GetType().FullName
                Write-Error $_
            }
        } catch {
            Write-Verbose $_.Exception.GetType().FullName
            Write-Error $_
        }
    } until ($exit)
}

<#
.SYNOPSIS
Get index(es) or a value in provided array from selection menu.
.PARAMETER Array
Array of strings to get the selection menu.
.PARAMETER Message
Optional menu header to display.
.PARAMETER Value
Flag to return value(s) instead of index(es).
.PARAMETER List
Flag to choose from selection list instead of single value.
#>
function Get-ArrayIndexMenu {
    [CmdletBinding(DefaultParameterSetName = 'Index')]
    [OutputType([int], ParameterSetName = 'Index')]
    [OutputType([string], ParameterSetName = 'Value')]
    param (
        [Parameter(Mandatory, Position = 0)]
        [object[]]$Array,

        [Parameter(Position = 1)]
        [string]$Message,

        [Parameter(Mandatory, ParameterSetName = 'Value')]
        [switch]$Value,

        [switch]$List
    )

    begin {
        # convert objects in array to strings
        if ($Array[0].GetType().FullName -ne 'System.String') {
            $Array = $Array | Format-Table -AutoSize -HideTableHeaders | Out-String -Stream | Where-Object { $_ }
        }
        # create selection message
        $menu = for ($i = 0; $i -lt $Array.Count; $i++) {
            [PSCustomObject]@{ I = "[$i]"; H = '-'; Value = $Array[$i] }
        }
        $selMsg = $menu | Format-Table -Property @{ Name = 'I'; Expression = { $_.I }; Alignment = 'right'}, H, Value -AutoSize -HideTableHeaders | Out-String

        # create prompt message
        if (-not $Message) {
            $Message = $List ? 'Enter comma/space separated selection list' : 'Enter selection'
        }
        $msg = "`n`e[4m$Message`e[0m:`n$selMsg"
    }

    process {
        # read and validate input
        do {
            [array]$inputArray = (Read-Host -Prompt $msg).Split([char[]]@(' ', ','), [StringSplitOptions]::RemoveEmptyEntries) | Select-Object -Unique
        } while (($inputArray.ForEach({ $_ -in 0..($Array.Count - 1) }) -contains $false) -or (-not $List -and $inputArray.Count -gt 1) -or (-not $inputArray))
    }

    end {
        return $Value ? $inputArray.ForEach{ $Array[$_] } : $inputArray
    }
}

<#
.SYNOPSIS
Print timespan in human readable format.
#>
function Format-Duration {
    [CmdletBinding()]
    param (
        [timespan]$TimeSpan
    )

    switch ($TimeSpan) {
        { $_.TotalMilliseconds -gt 0 -and $_.TotalMilliseconds -lt 10 } { '{0:N2}ms' -f $_.TotalMilliseconds }
        { $_.TotalMilliseconds -ge 10 -and $_.TotalMilliseconds -lt 100 } { '{0:N1}ms' -f $_.TotalMilliseconds }
        { $_.TotalMilliseconds -ge 100 -and $_.TotalMilliseconds -lt 1000 } { '{0:N0}ms' -f $_.TotalMilliseconds }
        { $_.TotalSeconds -ge 1 -and $_.TotalSeconds -lt 10 } { '{0:N3}s' -f $_.TotalSeconds }
        { $_.TotalSeconds -ge 10 -and $_.TotalSeconds -lt 100 } { '{0:N2}s' -f $_.TotalSeconds }
        { $_.TotalSeconds -ge 100 -and $_.TotalHours -le 1 } { $_.ToString('mm\:ss\.ff') }
        { $_.TotalHours -ge 1 -and $_.TotalDays -le 1 } { $_.ToString('hh\:mm\:ss') }
        { $_.TotalDays -ge 1 } { "$($_.Days * 24 + $_.Hours):$($_.ToString('mm\:ss'))" }
        Default { '0ms' }
    }
}

<#
.SYNOPSIS
Get the aliases for any cmdlet.
#>
function Get-CmdletAlias {
    [CmdletBinding()]
    param (
        [string]$CmdletName
    )

    Get-Alias | `
        Where-Object -FilterScript { $_.Definition -match $CmdletName } | `
        Sort-Object -Property Definition, Name | `
        Select-Object -Property Definition, Name
}

Set-Alias -Name alias -Value Get-CmdletAlias

<#
.SYNOPSIS
Generate a random string.
#>
function New-Password {
    [CmdletBinding()]
    [OutputType([string])]
    param (
        [Int]$Size = 8,

        [Char[]]$Complexity = 'ULNS',

        [Char[]]$Exclude
    )
    $AllTokens = @();
    $Chars = @();
    $TokenSets = @{
        UpperCase = [Char[]]'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
        LowerCase = [Char[]]'abcdefghijklmnopqrstuvwxyz'
        Numbers   = [Char[]]'0123456789'
        Symbols   = [Char[]]'!#%&*+-<>@^_|~'
    }
    $TokenSets.Keys | Where-Object { $Complexity -Contains $_[0] } | ForEach-Object {
        $TokenSet = $TokenSets.$_ | Where-Object { $Exclude -cNotContains $_ } | ForEach-Object { $_ }
        if ($_[0] -cle 'Z') {
            $Chars += $TokenSet | Get-Random
        }
        $AllTokens += $TokenSet
    }
    while ($Chars.Count -lt $Size) {
        $Chars += $AllTokens | Get-Random
    } -join ($Chars | Sort-Object { Get-Random })
}

<#
.SYNOPSIS
Check if PowerShell runs elevated.
#>
function Test-IsAdmin {
    [CmdletBinding()]
    [OutputType([bool])]
    param ()

    process {
        $isAdmin = if ($IsWindows) {
            ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]'Administrator')
        } else {
            ((id -u) -eq 0) ? $true : $false
        }
    }

    end {
        return $isAdmin
    }
}

<#
.SYNOPSIS
Fix executable bit based on shebang presence.
.DESCRIPTION
Process specified directory, looking for bash and powershell scripts, and sets executable bit based on shebang presence.
#>
function Invoke-FixExecutableBit {
    [CmdletBinding()]
    [OutputType([System.Void])]
    param (
        [Parameter(Position = 0)]
        [ValidateNotNullorEmpty()]
        [ValidateScript({ Test-Path $_ -PathType 'Container' }, ErrorMessage = "`e[1;4m{0}`e[22;24m is not valid path")]
        [string]$Path = '.'
    )

    begin {
        if (-not $IsLinux) {
            Write-Warning 'This script is intended to run on Linux only!'
            exit
        }
        if (-not (Get-Command rg -CommandType Application)) {
            Write-Warning 'ripgrep is missing!'
            exit
        }
        # viable script extensions
        [string[]]$extFilter = @('.ps1', '.sh')
    }

    process {
        # *adding executable bit in files with shebang
    (Get-ChildItem $Path -File -Recurse -Force).Where({
                $_.DirectoryName -notmatch '/\.git\b' `
                    -and ($_.Extension -in $extFilter -or -not $_.Extension) `
                    -and $_.UnixMode -notmatch '^-rwx' `
                    -and (Get-Content $_ -Head 1 | Select-String '^#!' -Quiet)
            }
        ).ForEach({
                Write-Host $_.FullName -ForegroundColor Green
                chmod +x $_.FullName
            }
        )

        # *removing executable bit from files without shebang
    (Get-ChildItem $Path -File -Recurse -Force).Where({
                $_.DirectoryName -notmatch '/\.git\b' `
                    -and ($_.Extension -in $extFilter -or -not $_.Extension) `
                    -and $_.UnixMode -match '^-rwx' `
                    -and (Get-Content $_ -Head 1 | Select-String '^#!' -NotMatch -Quiet)
            }
        ).ForEach({
                Write-Host $_.FullName
                chmod -x $_.FullName
            }
        )
    }
}

Set-Alias -Name feb -Value Invoke-FixExecutableBit
